<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <title>TKBD5_bot</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            padding: 0;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        :root {
            /* -- Updated all colors to white theme -- */
            --primary-color: #2ed914; /* Keep green for accents */
            --primary-hover: #3bff21;
            --secondary-color: #e0e0e0;
            --background-color: #ffffff;
            --text-color: #000000;
            --text-muted-color: #666666;
            --accent-color: #ff8c00;
            --card-bg: #f5f5f5;
            --error-color: #ff4444;
            --pending-color: #ffc107;
            --processing-color: #17a2b8;
            --success-color: #28a745;

            /* New dynamic color variables */
            --dynamic-primary-color: var(--primary-color);
            --dynamic-primary-hover: var(--primary-hover);
            --dynamic-success-color: var(--success-color);
            --dynamic-accent-color: var(--accent-color);
            --dynamic-secondary-color: var(--secondary-color);
            --dynamic-card-bg: var(--card-bg);
            --dynamic-error-color: var(--error-color);
            --dynamic-pending-color: var(--pending-color);
            --dynamic-processing-color: var(--processing-color);

            /* Dark mode variables */
            --dm-primary-color: #4CAF50;
            --dm-primary-hover: #66BB6A;
            --dm-secondary-color: #424242;
            --dm-background-color: #121212;
            --dm-text-color: #FFFFFF;
            --dm-text-muted-color: #BDBDBD;
            --dm-accent-color: #FFA726;
            --dm-card-bg: #1E1E1E;
            --dm-error-color: #EF5350;
            --dm-border-color: rgba(255, 255, 255, 0.1);

            /* Dark mode dynamic variables */
            --dm-dynamic-primary-color: var(--dm-primary-color);
            --dm-dynamic-primary-hover: var(--dm-primary-hover);
            --dm-dynamic-success-color: var(--dm-success-color);
            --dm-dynamic-accent-color: var(--dm-accent-color);
            --dm-dynamic-secondary-color: var(--dm-secondary-color);
            --dm-dynamic-card-bg: var(--dm-card-bg);
            --dm-dynamic-error-color: var(--dm-error-color);
            --dm-dynamic-pending-color: var(--dm-pending-color);
            --dm-dynamic-processing-color: var(--dm-processing-color);
        }

        .dark-mode {
            --primary-color: var(--dm-primary-color);
            --primary-hover: var(--dm-primary-hover);
            --secondary-color: var(--dm-secondary-color);
            --background-color: var(--dm-background-color);
            --text-color: var(--dm-text-color);
            --text-muted-color: var(--dm-text-muted-color);
            --accent-color: var(--dm-accent-color);
            --card-bg: var(--dm-card-bg);
            --error-color: var(--dm-error-color);
            --border-color: var(--dm-border-color);
            /* Update dynamic variables for dark mode */
            --dynamic-primary-color: var(--dm-dynamic-primary-color);
            --dynamic-primary-hover: var(--dm-dynamic-primary-hover);
            --dynamic-success-color: var(--dm-dynamic-success-color);
            --dynamic-accent-color: var(--dm-dynamic-accent-color);
            --dynamic-secondary-color: var(--dm-dynamic-secondary-color);
            --dynamic-card-bg: var(--dm-dynamic-card-bg);
            --dynamic-error-color: var(--dm-dynamic-error-color);
            --dynamic-pending-color: var(--dm-dynamic-pending-color);
            --dynamic-processing-color: var(--dm-dynamic-processing-color);
        }

        /* Header Styles */
        .app-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: var(--card-bg);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-color);
        }

        .header-icons {
            display: flex;
            gap: 15px;
        }

        .header-icon {
            font-size: 1.2rem;
            color: var(--text-muted-color);
            cursor: pointer;
            transition: color 0.3s;
        }

        .header-icon:hover {
            color: var(--dynamic-primary-color);
        }

        /* Main Content */
        .main-content {
            padding: 15px;
            padding-bottom: 80px; /* Space for bottom navigation */
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        /* Balance Card */
        .balance-card {
            background: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .balance-amount {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .balance-label {
            font-size: 1rem;
            opacity: 0.9;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background-color: var(--card-bg);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-muted-color);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .action-button {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color, #ddd);
            color: var(--text-color);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        .action-button:hover {
            background-color: var(--dynamic-card-bg); /* Updated to use dynamic color */
            transform: translateY(-2px);
        }

        .action-button i {
            font-size: 1.2rem;
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        /* Task Card */
        .task-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-left: 4px solid var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .task-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--text-color);
        }

        .task-reward {
            background-color: var(--dynamic-success-color); /* Updated to use dynamic color */
            color: white;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .task-description {
            color: var(--text-muted-color);
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .task-button {
            width: 100%;
            padding: 10px;
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .task-button:hover {
            background-color: var(--dynamic-primary-hover); /* Updated to use dynamic hover color */
        }

        .task-button:disabled {
            background-color: var(--dynamic-secondary-color); /* Updated to use dynamic secondary color */
            cursor: not-allowed;
        }

        .task-status {
            text-align: center;
            margin-top: 5px;
            font-size: 0.85rem;
            color: var(--text-muted-color);
        }

        /* Referral Section */
        .referral-section {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .referral-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
        }

        .referral-stat {
            text-align: center;
        }

        .referral-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .referral-stat-label {
            font-size: 0.9rem;
            color: var(--text-muted-color);
        }

        .referral-button {
            width: 100%;
            padding: 12px;
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .referral-button:hover {
            background-color: var(--dynamic-primary-hover); /* Updated to use dynamic hover color */
        }

        /* History List */
        .history-list {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .list-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color, #eee);
        }

        .list-item:last-child {
            border-bottom: none;
        }

        .history-icon {
            margin-right: 10px;
            font-size: 1.2rem;
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .info {
            flex: 1;
        }

        .name {
            font-weight: 500;
            color: var(--text-color);
        }

        .detail {
            font-size: 0.85rem;
            color: var(--text-muted-color);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: var(--background-color);
            color: var(--text-color);
            width: 90%;
            max-width: 500px;
            border-radius: 10px;
            overflow: hidden;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            padding: 15px;
            background-color: var(--card-bg);
            border-bottom: 1px solid var(--border-color, #eee);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-color);
        }

        .modal-body {
            padding: 20px;
        }

        /* Input Styles */
        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-color);
        }

        .input-field {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color, #ddd);
            border-radius: 5px;
            background-color: var(--card-bg);
            color: var(--text-color);
            font-size: 1rem;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        /* Button Styles */
        .primary-button {
            width: 100%;
            padding: 12px;
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .primary-button:hover {
            background-color: var(--dynamic-primary-hover); /* Updated to use dynamic hover color */
        }

        .primary-button:disabled {
            background-color: var(--dynamic-secondary-color); /* Updated to use dynamic secondary color */
            cursor: not-allowed;
        }

        .secondary-button {
            width: 100%;
            padding: 12px;
            background-color: var(--dynamic-secondary-color); /* Updated to use dynamic secondary color */
            color: var(--text-color);
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .secondary-button:hover {
            background-color: #555; /* A slightly darker shade for hover */
        }

        .buy-button {
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
            width: 100%;
        }

        .buy-button:hover {
            background-color: var(--dynamic-primary-hover); /* Updated to use dynamic hover color */
        }

        .buy-button:disabled {
            background-color: var(--dynamic-secondary-color); /* Updated to use dynamic secondary color */
            cursor: not-allowed;
        }

        /* Status Indicators */
        .status-indicator {
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .status-pending {
            background-color: var(--dynamic-pending-color); /* Updated to use dynamic color */
            color: #856404;
        }

        .status-processing {
            background-color: var(--dynamic-processing-color); /* Updated to use dynamic color */
            color: #004085;
        }

        .status-completed {
            background-color: var(--dynamic-success-color); /* Updated to use dynamic color */
            color: #155724;
        }

        .status-rejected {
            background-color: var(--dynamic-error-color); /* Updated to use dynamic color */
            color: #721c24;
        }

        /* Chat Interface Styles (if applicable, though less common in a bot UI) */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 300px; /* Fixed height for demo */
            border: 1px solid var(--border-color, #ddd);
            border-radius: 10px;
            overflow: hidden;
            background-color: var(--card-bg);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .message {
            padding: 8px 12px;
            border-radius: 10px;
            margin-bottom: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .user-message {
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: #000; /* Ensure text is readable on green */
            align-self: flex-end;
        }

        .admin-message {
            background-color: var(--dynamic-secondary-color); /* Updated to use dynamic secondary color */
            color: var(--text-color);
            align-self: flex-start;
        }

        .chat-input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid var(--border-color, #ddd);
            background-color: var(--card-bg);
        }

        #admin-message-input {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border-color, #ddd);
            border-radius: 5px;
            background-color: var(--card-bg);
            color: var(--text-color);
        }

        #send-admin-message {
            margin-left: 10px;
            padding: 8px 15px;
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #send-admin-message:hover {
            background-color: var(--dynamic-primary-hover); /* Updated to use dynamic hover color */
        }

        /* Leaderboard Styles */
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color, #eee);
        }

        .leaderboard-rank {
            font-weight: bold;
            color: var(--dynamic-accent-color); /* Updated to use dynamic accent color */
        }

        .leaderboard-name {
            flex: 1;
            margin: 0 15px;
            color: var(--text-color);
        }

        .leaderboard-earnings {
            color: var(--dynamic-success-color); /* Updated to use dynamic success color */
            font-weight: 500;
        }

        /* Notification Item */
        .notification-item {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .notification-item h4 {
            margin: 0 0 5px 0;
            color: var(--text-color);
        }

        .notification-item p {
            margin: 0;
            color: var(--text-muted-color);
            font-size: 0.95rem;
        }

        /* VIP Package Card */
        .vip-package-card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-left: 4px solid var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .vip-package-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--text-color);
            margin-bottom: 5px;
        }

        .vip-package-price {
            color: var(--dynamic-success-color); /* Updated to use dynamic success color */
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .vip-package-benefits {
            color: var(--text-muted-color);
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .vip-package-status {
            font-size: 0.85rem;
            margin-top: 5px;
            color: var(--text-muted-color);
        }

        .vip-watch-button {
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            width: 100%;
            transition: background-color 0.3s;
        }

        .vip-watch-button:hover {
            background-color: var(--dynamic-primary-hover); /* Updated to use dynamic hover color */
        }

        .vip-watch-button:disabled {
            background-color: var(--dynamic-secondary-color); /* Updated to use dynamic secondary color */
            cursor: not-allowed;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--card-bg);
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: var(--text-muted-color);
            font-size: 0.8rem;
            transition: color 0.3s;
        }

        .nav-item.active {
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .nav-item i {
            font-size: 1.2rem;
            margin-bottom: 3px;
        }

        .nav-item:hover {
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .header-title {
                font-size: 1.3rem;
            }
            .balance-amount {
                font-size: 1.8rem;
            }
            .stat-value {
                font-size: 1.3rem;
            }
            .task-title {
                font-size: 1rem;
            }
        }

        /* Loading Spinner */
        .spinner {
            border: 2px solid var(--card-bg);
            border-top: 2px solid var(--dynamic-primary-color); /* Updated to use dynamic color */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error message */
        .error-message {
            color: var(--dynamic-error-color); /* Updated to use dynamic color */
            text-align: center;
            margin: 10px 0;
        }

        /* Success message */
        .success-message {
            color: var(--dynamic-success-color); /* Updated to use dynamic color */
            text-align: center;
            margin: 10px 0;
        }

        /* Info message */
        .info-message {
            color: var(--dynamic-accent-color); /* Updated to use dynamic color */
            text-align: center;
            margin: 10px 0;
        }

        /* User Avatar (if used elsewhere) */
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--dynamic-primary-color), var(--dynamic-primary-color)); /* Updated to use dynamic color */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1rem;
        }

        /* Tooltip (if implemented) */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: var(--text-color);
            color: var(--background-color);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Table styles (if history is displayed in a table) */
        .history-table {
            width: 100%;
            border-collapse: collapse;
        }

        .history-table th,
        .history-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border-color, #ddd);
        }

        .history-table th {
            background-color: var(--card-bg);
            color: var(--text-color);
        }

        /* Responsive table */
        @media (max-width: 600px) {
            .history-table,
            .history-table thead,
            .history-table tbody,
            .history-table th,
            .history-table td,
            .history-table tr {
                display: block;
            }

            .history-table thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }

            .history-table tr {
                border: 1px solid var(--border-color, #ccc);
                margin-bottom: 10px;
                padding: 10px;
                border-radius: 5px;
            }

            .history-table td {
                border: none;
                position: relative;
                padding-left: 50%;
            }

            .history-table td:before {
                content: attr(data-label) ": ";
                position: absolute;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: bold;
            }
        }

        /* Checkbox and Toggle styles */
        .checkbox-container {
            display: block;
            position: relative;
            padding-left: 35px;
            margin-bottom: 12px;
            cursor: pointer;
            font-size: 1rem;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            color: var(--text-color);
        }

        .checkbox-container input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color, #ccc);
            border-radius: 4px;
        }

        .checkbox-container:hover input ~ .checkmark {
            background-color: var(--dynamic-card-bg); /* Updated to use dynamic color */
        }

        .checkbox-container input:checked ~ .checkmark {
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
        }

        .checkbox-container input:checked ~ .checkmark:after {
            display: block;
        }

        .checkbox-container .checkmark:after {
            left: 7px;
            top: 3px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        /* Radio Button styles */
        .radio-container {
            display: block;
            position: relative;
            padding-left: 35px;
            margin-bottom: 12px;
            cursor: pointer;
            font-size: 1rem;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            color: var(--text-color);
        }

        .radio-container input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
        }

        .radiomark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color, #ccc);
            border-radius: 50%;
        }

        .radio-container:hover input ~ .radiomark {
            background-color: var(--dynamic-card-bg); /* Updated to use dynamic color */
        }

        .radio-container input:checked ~ .radiomark {
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .radiomark:after {
            content: "";
            position: absolute;
            display: none;
        }

        .radio-container input:checked ~ .radiomark:after {
            display: block;
        }

        .radio-container .radiomark:after {
            top: 6px;
            left: 6px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: white;
        }

        /* Range Slider styles */
        .slider-container {
            width: 100%;
            margin: 15px 0;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--card-bg); /* Updated to use dynamic color */
            outline: none;
            -webkit-transition: .2s;
            transition: .2s;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--dynamic-primary-color); /* Updated to use dynamic color */
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--dynamic-primary-color); /* Updated to use dynamic color */
            cursor: pointer;
        }

        /* Select Dropdown styles */
        .select-field {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color, #ddd);
            border-radius: 5px;
            background-color: var(--card-bg);
            color: var(--text-color);
            font-size: 1rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='var(--text-muted-color)'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
        }

        .select-field:focus {
            outline: none;
            border-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        /* Badge styles */
        .badge {
            display: inline-block;
            padding: 3px 6px;
            font-size: 0.75rem;
            font-weight: bold;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 5px;
            color: white;
        }

        .badge-primary {
            background-color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .badge-success {
            background-color: var(--dynamic-success-color); /* Updated to use dynamic color */
        }

        .badge-warning {
            background-color: var(--dynamic-pending-color); /* Updated to use dynamic color */
        }

        .badge-danger {
            background-color: var(--dynamic-error-color); /* Updated to use dynamic color */
        }

        /* Alert styles */
        .alert {
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid transparent;
            border-radius: 5px;
        }

        .alert-info {
            color: var(--dynamic-accent-color); /* Updated to use dynamic color */
            background-color: rgba(255, 140, 0, 0.1); /* Light accent background */
            border-color: var(--dynamic-accent-color); /* Updated to use dynamic color */
        }

        .alert-success {
            color: var(--dynamic-success-color); /* Updated to use dynamic color */
            background-color: rgba(40, 167, 69, 0.1); /* Light success background */
            border-color: var(--dynamic-success-color); /* Updated to use dynamic color */
        }

        .alert-warning {
            color: var(--dynamic-pending-color); /* Updated to use dynamic color */
            background-color: rgba(255, 193, 7, 0.1); /* Light pending background */
            border-color: var(--dynamic-pending-color); /* Updated to use dynamic color */
        }

        .alert-danger {
            color: var(--dynamic-error-color); /* Updated to use dynamic color */
            background-color: rgba(220, 53, 69, 0.1); /* Light error background */
            border-color: var(--dynamic-error-color); /* Updated to use dynamic color */
        }

        /* Card styles */
        .card {
            background-color: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Link styles */
        a {
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Text styles */
        .text-primary {
            color: var(--dynamic-primary-color); /* Updated to use dynamic color */
        }

        .text-success {
            color: var(--dynamic-success-color); /* Updated to use dynamic color */
        }

        .text-warning {
            color: var(--dynamic-pending-color); /* Updated to use dynamic color */
        }

        .text-danger {
            color: var(--dynamic-error-color); /* Updated to use dynamic color */
        }

        .text-muted {
            color: var(--text-muted-color);
        }

        /* Utility classes */
        .text-center {
            text-align: center;
        }

        .text-right {
            text-align: right;
        }

        .text-left {
            text-align: left;
        }

        .d-none {
            display: none;
        }

        .d-block {
            display: block;
        }

        .d-flex {
            display: flex;
        }

        .justify-content-center {
            justify-content: center;
        }

        .justify-content-between {
            justify-content: space-between;
        }

        .align-items-center {
            align-items: center;
        }

        .flex-column {
            flex-direction: column;
        }

        .m-1 { margin: 0.25rem; }
        .m-2 { margin: 0.5rem; }
        .m-3 { margin: 1rem; }
        .m-4 { margin: 1.5rem; }
        .m-5 { margin: 3rem; }

        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-3 { margin-top: 1rem; }
        .mt-4 { margin-top: 1.5rem; }
        .mt-5 { margin-top: 3rem; }

        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-3 { margin-bottom: 1rem; }
        .mb-4 { margin-bottom: 1.5rem; }
        .mb-5 { margin-bottom: 3rem; }

        .p-1 { padding: 0.25rem; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 1rem; }
        .p-4 { padding: 1.5rem; }
        .p-5 { padding: 3rem; }

        .pt-1 { padding-top: 0.25rem; }
        .pt-2 { padding-top: 0.5rem; }
        .pt-3 { padding-top: 1rem; }
        .pt-4 { padding-top: 1.5rem; }
        .pt-5 { padding-top: 3rem; }

        .pb-1 { padding-bottom: 0.25rem; }
        .pb-2 { padding-bottom: 0.5rem; }
        .pb-3 { padding-bottom: 1rem; }
        .pb-4 { padding-bottom: 1.5rem; }
        .pb-5 { padding-bottom: 3rem; }

        /* Ensure notification modal list items are styled consistently */
        #important-notices-list .notification-item {
            background: var(--card-bg);
            padding: 18px; /* Increased padding */
            border-radius: 12px; /* Increased border-radius */
            margin-bottom: 15px; /* Increased margin */
            border: 1px solid var(--border-color);
        }
        #important-notices-list .notification-item h4 {
            margin: 0 0 8px 0; /* Increased margin */
            font-size: 18px; /* Increased font size */
        }
        #important-notices-list .notification-item p {
            margin: 0 0 8px 0; /* Increased margin */
            font-size: 16px; /* Increased font size */
            color: var(--text-muted-color);
        }

    </style>
</head>
<body>
    <!-- Your HTML content goes here -->
    <div id="app">
        <!-- Views will be injected here by JavaScript -->
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            // Your existing config
            apiKey: "AIzaSyDDC68e27952T983Bq01LkV5Hj4mNz0Y2o",
            authDomain: "tkbd5-bot.firebaseapp.com",
            projectId: "tkbd5-bot",
            storageBucket: "tkbd5-bot.appspot.com",
            messagingSenderId: "25930019210",
            appId: "1:25930019210:web:6441562811d3e7e9631873",
            measurementId: "G-P9HX6XXT1Q"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // - State Variables -
        let points = 0;
        let balance = 0.00;
        let historyLog = [];
        let withdrawHistory = [];
        let tgUser = null;
        let isBlocked = false;
        let lastAdWatchTime = null; // Track last ad watch time
        let adCooldownMs = 0; // Default, will be fetched from config
        let vipPackages = [];
        let userVipSubscriptions = {}; // To store user's active/pending subscriptions
        let vipUpdateInterval = null; // For background updates

        // App Configuration (loaded from Firebase)
        let appConfig = {
            pointsPerAd: 10,
            coinsForConversion: 1000, // e.g., 1000 coins = $0.30
            valuePerConversion: 0.30, // e.g., 1000 coins = $0.30
            referralRewardCoins: 10, // Default value
            referralClaimThreshold: 200, // Default value
            minWithdrawAmount: 5, // Default value
            dailyAdLimitPerUser: 10, // Default daily ad limit
            isAdSystemActive: true, // Default ad system status
            usdToBdtRate: 120, // Default: 1 USD = 120 BDT
            balanceCardBgGradient: "linear-gradient(135deg, #00a651, #00753a)", // Default gradient - NOW REPLACED BY COLOR
            depositInstructionText: "Please send money to: ", // Default instruction text
            depositNumber: "01814892156", // Default number
            depositInstructionBgColor: "#f8f9fa", // Default background color
            depositInstructionTextColor: "var(--text-color)", // Default text color
            depositNumberColor: "var(--accent-color)", // Default number color
            // New config for dynamic colors
            primaryColor: "#2ed914", // Default green
            balanceCardBgColor: "#00a651" // Default balance card color
        };

        // - Updated Balance Logic -
        // Dynamic from Firebase: 1000 coins = 30 cents = $0.30 USD
        // 1 coin = $0.0003 USD (calculated dynamically)

        // - Core App Logic -
        function initApp() {
            if (window.Telegram && Telegram.WebApp) {
                Telegram.WebApp.ready();
                Telegram.WebApp.expand();
                tgUser = Telegram.WebApp.initDataUnsafe.user;

                if (!tgUser) {
                    // Don't show blocked view immediately, wait for Firebase check
                    console.log("Telegram user data not available immediately, waiting for Firebase check");
                    showView('home-view'); // Show home view initially
                    loadAppConfig().then(() => {
                        loadUserData().then(() => {
                            loadTelegramUser();
                            renderLeaderboard();
                            checkForReferral(); // Check if this user was referred
                            loadVipPackages(); // Load VIP packages
                            loadUserVipSubscriptions(); // Load user's VIP subscriptions
                            startVipUpdateInterval(); // Start background update for VIP data
                        }).catch(error => {
                            console.error("Error loading user data:", error);
                            // Optionally show an error message to the user
                        });
                    }).catch(error => {
                        console.error("Error loading app config:", error);
                        // Optionally show an error message to the user
                    });
                } else {
                    loadAppConfig().then(() => {
                        loadUserData().then(() => {
                            loadTelegramUser();
                            renderLeaderboard();
                            checkForReferral();
                            loadVipPackages();
                            loadUserVipSubscriptions();
                            startVipUpdateInterval();
                        }).catch(error => {
                            console.error("Error loading user data:", error);
                        });
                    }).catch(error => {
                        console.error("Error loading app config:", error);
                    });
                }
            } else {
                console.error("Telegram WebApp not available.");
                // Fallback or error handling if Telegram object isn't available
                // For development, you might simulate tgUser
                // tgUser = { id: 123456789, username: 'dev_user', first_name: 'Dev' };
                // loadAppConfig();
                // loadUserData();
                // loadTelegramUser();
            }
        }

        // Function to load app configuration from Firebase
        async function loadAppConfig() {
            try {
                const snapshot = await database.ref('appConfig').once('value');
                const config = snapshot.val();
                if (config) {
                    appConfig = {
                        pointsPerAd: config.pointsPerAd !== undefined ? config.pointsPerAd : 10,
                        coinsForConversion: config.coinsForConversion !== undefined ? config.coinsForConversion : 1000,
                        valuePerConversion: config.valuePerConversion !== undefined ? config.valuePerConversion : 0.30,
                        referralRewardCoins: config.referralRewardCoins !== undefined ? config.referralRewardCoins : 10,
                        referralClaimThreshold: config.referralClaimThreshold !== undefined ? config.referralClaimThreshold : 200,
                        minWithdrawAmount: config.minWithdrawAmount !== undefined ? config.minWithdrawAmount : 5,
                        dailyAdLimitPerUser: config.dailyAdLimitPerUser !== undefined ? config.dailyAdLimitPerUser : 10,
                        isAdSystemActive: config.isAdSystemActive !== undefined ? config.isAdSystemActive : true,
                        usdToBdtRate: config.usdToBdtRate !== undefined ? config.usdToBdtRate : 120,
                        // Updated for dynamic color - NOW USING balanceCardBgColor instead of gradient
                        balanceCardBgColor: config.balanceCardBgColor || "#00a651", // Use solid color
                        depositInstructionText: config.depositInstructionText || "Please send money to: ",
                        depositNumber: config.depositNumber || "01814892156",
                        depositInstructionBgColor: config.depositInstructionBgColor || "#f8f9fa",
                        depositInstructionTextColor: config.depositInstructionTextColor || "var(--text-color)",
                        depositNumberColor: config.depositNumberColor || "var(--accent-color)",
                        // Load new dynamic color config
                        primaryColor: config.primaryColor || "#2ed914"
                    };
                    console.log("App config loaded:", appConfig);

                    // Update dynamic colors after config is loaded
                    updateDynamicColors();
                } else {
                    console.log("No app config found in Firebase, using defaults.");
                    // Update dynamic colors with defaults if no config found
                    updateDynamicColors();
                }
            } catch (error) {
                console.error("Failed to load app config:", error);
                throw error; // Re-throw to be caught by calling function
            }
        }

        // Function to update CSS variables based on appConfig
        function updateDynamicColors() {
            const root = document.documentElement;

            // Set dynamic color variables
            root.style.setProperty('--dynamic-primary-color', appConfig.primaryColor);
            root.style.setProperty('--dynamic-primary-hover', appConfig.primaryColor); // Or calculate a darker/lighter shade
            root.style.setProperty('--dynamic-success-color', appConfig.primaryColor); // Use primary for success
            root.style.setProperty('--dynamic-accent-color', appConfig.primaryColor); // Use primary for accent if needed
            // Add more as needed, e.g., for borders, backgrounds, etc.

            // Update balance card background color (replacing the old gradient logic)
            const balanceCard = document.querySelector('.balance-card');
            if (balanceCard) {
                // Use the solid color from config
                balanceCard.style.background = appConfig.balanceCardBgColor;
                // Ensure text remains readable, maybe adjust based on luminance later if needed
            }

            console.log("Dynamic colors updated from config:", appConfig.primaryColor, appConfig.balanceCardBgColor);
        }


        // Function to load user data from Firebase
        async function loadUserData() {
            if (!tgUser || !tgUser.id) return Promise.resolve(); // Resolve immediately if no user ID

            try {
                const userRef = database.ref('users/' + tgUser.id);
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();

                if (userData) {
                    points = userData.points || 0;
                    balance = userData.balance || 0.00;
                    historyLog = userData.historyLog || [];
                    isBlocked = userData.isBlocked || false;
                    lastAdWatchTime = userData.lastAdWatchTime ? new Date(userData.lastAdWatchTime) : null; // Parse timestamp

                    // Check if user has exceeded daily ad limit
                    const today = new Date().toDateString();
                    const userAdsToday = userData.adsWatchedToday || 0;
                    if (today === (lastAdWatchTime ? lastAdWatchTime.toDateString() : null) && userAdsToday >= appConfig.dailyAdLimitPerUser) {
                        disableAdButton(); // Disable button if limit reached today
                    } else {
                        enableAdButton(); // Ensure button is enabled otherwise
                    }

                    updateDisplay();
                    renderHistoryList();

                    // Only show blocked view if user is actually blocked
                    if (isBlocked) {
                        showBlockedView();
                    }

                    // Set up real-time listeners
                    setupBlockingListener(userRef);
                    setupWithdrawHistoryListener(userRef);
                    setupPointsBalanceListener(userRef);
                    setupReferralListener(userRef);
                    setupAppConfigListener(); // Setup listener for app config changes
                    setupUserAdDataListener(userRef); // Setup listener for user ad data
                } else {
                    // Initialize new user
                    await userRef.set({
                        id: tgUser.id,
                        username: tgUser.username || 'Unknown',
                        firstName: tgUser.first_name || 'User',
                        points: 0,
                        balance: 0.00,
                        isBlocked: false,
                        referralCount: 0,
                        referralEarnings: 0,
                        adsWatchedToday: 0,
                        lastAdWatchTime: null,
                        adStatus: 'Active', // Default status
                        createdAt: new Date().toISOString()
                    });

                    // Set up real-time listeners
                    setupBlockingListener(userRef);
                    setupWithdrawHistoryListener(userRef);
                    setupPointsBalanceListener(userRef);
                    setupReferralListener(userRef);
                    setupAppConfigListener(); // Setup listener for app config changes
                    setupUserAdDataListener(userRef); // Setup listener for user ad data

                    points = 0;
                    balance = 0.00;
                    historyLog = [];
                    lastAdWatchTime = null;
                    updateDisplay();
                    renderHistoryList();
                }

                // - New: Ensure timer starts for existing users too -
                // Check if lastAdWatchTime exists for existing user, if not, set it
                if (userData && !userData.lastAdWatchTime) {
                    const nowForTimer = new Date();
                    try {
                        await userRef.update({
                            lastAdWatchTime: nowForTimer.toISOString()
                        });
                        lastAdWatchTime = nowForTimer; // Update local variable
                        console.log("Initial lastAdWatchTime set for existing user to start timer.");
                    } catch (error) {
                        console.error("Failed to set initial lastAdWatchTime for existing user:", error);
                    }
                }

            } catch (error) {
                console.error("Error loading user data:", error);
                // Optionally show an error message to the user
            }
        }


        // Function to load Telegram user data and update UI
        function loadTelegramUser() {
            if (tgUser) {
                document.getElementById('user-name').textContent = tgUser.first_name || 'User';
                // You can load other user data here if needed
            }
        }

        // Function to update the display with current points and balance
        function updateDisplay() {
            const balanceElement = document.getElementById('balance-amount');
            const pointsElement = document.getElementById('points-count');
            const balanceTextElement = document.getElementById('balance-text'); // If you have a separate text element

            if (balanceElement) {
                balanceElement.textContent = `$${balance.toFixed(2)}`;
            }
            if (pointsElement) {
                pointsElement.textContent = points;
            }
            // Update other balance references if they exist
            if (balanceTextElement) {
                balanceTextElement.textContent = `Balance: $${balance.toFixed(2)}`;
            }

            // Update withdraw amount input max based on balance
            const withdrawAmountInput = document.getElementById('withdrawAmount');
            if (withdrawAmountInput) {
                withdrawAmountInput.max = balance;
            }
        }

        // Function to grant reward and update UI
        async function grantReward() {
            const userRef = database.ref('users/' + tgUser.id);

            // Calculate new points and balance based on conversion rate
            points += appConfig.pointsPerAd;
            balance = points / appConfig.coinsForConversion * appConfig.valuePerConversion;

            // Update Firebase
            try {
                await userRef.update({
                    points: points,
                    balance: balance
                });

                // Add to history log
                const newHistoryItem = {
                    id: Date.now(), // Use timestamp as a simple ID
                    detail: `+${appConfig.pointsPerAd} coins from watching an ad`,
                    type: 'ad_reward', // Type for categorization
                    timestamp: new Date().toISOString()
                };
                historyLog.unshift(newHistoryItem); // Add to the beginning of the array

                // Update UI
                updateDisplay();
                renderHistoryList();
                showMessageModal('Reward Granted', `You earned +${appConfig.pointsPerAd} coins! Your new balance is $${balance.toFixed(2)}.`);
            } catch (error) {
                console.error("Error updating user data after reward:", error);
                showMessageModal('Error', 'Failed to update your balance. Please try again.');
                // Optionally revert the local changes if update fails
            }
        }


        // Function to handle ad button click
        async function handleAdButtonClick() {
            if (isBlocked) {
                showBlockedView();
                return;
            }

            if (!appConfig.isAdSystemActive) {
                showMessageModal('Info', 'Ad system is currently inactive. Please try again later.');
                return;
            }

            // Check daily limit logic (client-side check, server-side is authoritative)
            const today = new Date().toDateString();
            const lastWatchDate = lastAdWatchTime ? lastAdWatchTime.toDateString() : null;
            const userRef = database.ref('users/' + tgUser.id);

            try {
                // Get current ad count from Firebase to be sure
                const snapshot = await userRef.child('adsWatchedToday').once('value');
                const currentAdsToday = snapshot.val() || 0;

                if (today === lastWatchDate && currentAdsToday >= appConfig.dailyAdLimitPerUser) {
                    showMessageModal('Limit Reached', `You have reached your daily ad limit of ${appConfig.dailyAdLimitPerUser}. Please come back tomorrow.`);
                    disableAdButton(); // Ensure button is disabled
                    return;
                }

                // Attempt to show the ad using Monetag SDK function
                // Replace 'show_9807992' with your actual Monetag placement ID function
                if (typeof show_9807992 === 'function') {
                    // Disable button immediately to prevent double clicks
                    const adButton = document.getElementById('watch-ad-button');
                    if (adButton) {
                        adButton.disabled = true;
                        adButton.textContent = 'Loading...';
                    }

                    show_9807992() // This is the Monetag function
                        .then(async (result) => {
                            console.log("Ad result:", result);
                            if (result && (result.watched === true || result.status === 'completed')) { // Check for successful watch based on your SDK
                                await grantReward();
                            } else {
                                console.log("Ad was not completed or skipped.");
                                showMessageModal('Info', 'Ad was not completed. No reward given.');
                            }
                        })
                        .catch(async (err) => {
                            console.error("Error attempting to open ad links:", err);
                            // Decide whether to grant reward on JS error. Requirement says user gets coin " ".
                            // Granting it to be consistent.
                            // Update tracking first
                            await updateAdTracking();
                            await grantReward();
                            // Button states are updated in updateAdTracking
                            // Optionally show a message to the user
                            // showMessageModal('Error', 'An error occurred. Reward granted anyway.');
                        })
                        .finally(() => {
                            // Button re-enable is handled in updateAdTracking via listener, so no need to re-enable here immediately
                        });
                } else {
                    console.warn("Monetag SDK function 'show_9807992' is not available.");
                    showMessageModal('Error', 'Ad service is not ready. Please try again later.');
                    // Re-enable button if SDK is not ready
                    enableAdButton();
                }
            } catch (error) {
                console.error("Error checking ad limit or showing ad:", error);
                showMessageModal('Error', 'Failed to process ad request. Please try again.');
                enableAdButton();
            }
        }


        // Function to update ad tracking data in Firebase
        async function updateAdTracking() {
            if (!tgUser || !tgUser.id) return;

            const userRef = database.ref('users/' + tgUser.id);
            const now = new Date();
            const today = now.toDateString();

            try {
                // Get current data to check date and count
                const snapshot = await userRef.once('value');
                const userData = snapshot.val();
                const lastWatchDate = userData && userData.lastAdWatchTime ? new Date(userData.lastAdWatchTime).toDateString() : null;
                let adsToday = userData && userData.adsWatchedToday ? userData.adsWatchedToday : 0;

                // If it's a new day, reset the count
                if (lastWatchDate !== today) {
                    adsToday = 0;
                }
                adsToday += 1; // Increment for this watch

                // Update Firebase
                await userRef.update({
                    adsWatchedToday: adsToday,
                    lastAdWatchTime: now.toISOString()
                });

                // Update local state
                lastAdWatchTime = now;
                // The listener for user data will update the UI and re-enable the button if needed
            } catch (error) {
                console.error("Error updating ad tracking:", error);
                // If tracking fails, the button might stay disabled, which is okay as it prevents spam.
                // We could re-enable it here, but it's safer to rely on the listener.
            }
        }


        // Function to enable the ad button
        function enableAdButton() {
            const adButton = document.getElementById('watch-ad-button');
            if (adButton) {
                adButton.disabled = false;
                adButton.textContent = 'Watch Ad & Earn'; // Or whatever your original text was
            }
        }

        // Function to disable the ad button
        function disableAdButton() {
            const adButton = document.getElementById('watch-ad-button');
            if (adButton) {
                adButton.disabled = true;
                adButton.textContent = `Daily Limit Reached (${appConfig.dailyAdLimitPerUser})`;
            }
        }

        // Function to update ad button states based on Firebase data (called by listener)
        function updateAdButtonStates(userData) {
            if (!userData) return;

            const today = new Date().toDateString();
            const lastWatchDate = userData.lastAdWatchTime ? new Date(userData.lastAdWatchTime).toDateString() : null;
            const adsToday = userData.adsWatchedToday || 0;

            if (today === lastWatchDate && adsToday >= appConfig.dailyAdLimitPerUser) {
                disableAdButton();
            } else {
                enableAdButton();
            }
        }


        // Function to save user data (points, balance, history) to Firebase
        async function saveUserData() {
            if (!tgUser || !tgUser.id) return;

            const userRef = database.ref('users/' + tgUser.id);
            try {
                await userRef.update({
                    points: points,
                    balance: balance,
                    historyLog: historyLog // Note: Large history arrays might hit size limits, consider capping
                });
                console.log("User data saved successfully.");
            } catch (error) {
                console.error("Error saving user data:", error);
                // Optionally inform the user that data might not be saved
            }
        }


        // Function to update user balance and points, and add to history
        async function updateUserBalanceAndPoints(userRef, newPoints, newBalance, historyDetail) {
            try {
                await userRef.update({
                    points: newPoints,
                    balance: newBalance
                });

                // Add to history log if detail is provided
                if (historyDetail) {
                    const newHistoryItem = {
                        id: Date.now(), // Use timestamp as a simple ID
                        detail: historyDetail,
                        type: 'system', // Type for categorization
                        timestamp: new Date().toISOString()
                    };
                    historyLog.unshift(newHistoryItem); // Add to the beginning of the array

                    // Save updated history
                    await userRef.update({
                        historyLog: historyLog
                    });
                }

                // Update local state and UI
                points = newPoints;
                balance = newBalance;
                updateDisplay();
                renderHistoryList();
            } catch (error) {
                console.error("Error updating user balance/points/history in Firebase:", error);
                throw error; // Re-throw so calling function can handle it
            }
        }


        // Function to show a specific view
        function showView(viewId) {
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                view.classList.remove('active');
            });

            // Show the requested view
            const viewElement = document.getElementById(viewId);
            if (viewElement) {
                viewElement.classList.add('active');
            }
        }


        // Function to show the blocked view
        function showBlockedView() {
            showView('blocked-view');
        }


        // Function to render the history list
        function renderHistoryList() {
            const historyContainer = document.getElementById('history-list');
            if (!historyContainer) return;

            historyContainer.innerHTML = historyLog.map(item => {
                // Determine icon based on type
                const icon = item.type === 'ad_reward' ?
                    '<i class="fa-solid fa-coins" style="color: var(--dynamic-primary-color);"></i>' : // Updated to use dynamic color
                    (item.type === 'referral' ?
                        '<i class="fa-solid fa-user-plus" style="color: var(--dynamic-success-color);"></i>' : // Updated to use dynamic color
                        (item.type === 'withdrawal' ?
                            '<i class="fa-solid fa-money-bill-transfer" style="color: var(--dynamic-error-color);"></i>' : // Updated to use dynamic color
                            (item.type === 'system' ?
                                '<i class="fa-solid fa-rotate-left" style="color: var(--dynamic-success-color);"></i>' : // Updated to use dynamic color
                                '<i class="fa-solid fa-info-circle" style="color: var(--dynamic-accent-color);"></i>' // Updated to use dynamic color
                            )
                        )
                    );
                return `
                    <div class="list-item">
                        <div class="history-icon">${icon}</div>
                        <div class="info">
                            <div class="name">${item.detail}</div>
                            <div class="detail">${new Date(item.timestamp).toLocaleString()}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }


        // - Withdraw History Modal Logic -
        function openWithdrawHistoryModal() {
            renderWithdrawHistoryModal();
            document.getElementById('withdraw-history-modal').classList.add('active');
        }

        function closeWithdrawHistoryModal() {
            document.getElementById('withdraw-history-modal').classList.remove('active');
        }

        function renderWithdrawHistoryModal() {
            const modalBody = document.querySelector('#withdraw-history-modal .modal-body');
            if (!modalBody) return;

            if (withdrawHistory.length === 0) {
                modalBody.innerHTML = '<p class="text-muted">No withdrawal requests found.</p>';
                return;
            }

            modalBody.innerHTML = withdrawHistory.map(request => {
                let statusClass = '';
                let statusText = request.status;
                switch (request.status) {
                    case 'Pending':
                        statusClass = 'status-pending';
                        break;
                    case 'Processing':
                        statusClass = 'status-processing';
                        break;
                    case 'Completed':
                        statusClass = 'status-completed';
                        break;
                    case 'Rejected':
                        statusClass = 'status-rejected';
                        break;
                    default:
                        statusClass = ''; // Or a default class
                }
                return `
                    <div class="list-item">
                        <div class="info">
                            <div class="name">Withdrawal: $${parseFloat(request.amount).toFixed(2)}</div>
                            <div class="detail">${new Date(request.timestamp).toLocaleString()}</div>
                        </div>
                        <div class="status-indicator ${statusClass}">${statusText}</div>
                    </div>
                `;
            }).join('');
        }


        // Function to show a message modal
        function showMessageModal(title, message) {
            const modal = document.getElementById('message-modal');
            const titleElement = document.getElementById('message-modal-title');
            const messageElement = document.getElementById('message-modal-message');

            if (titleElement) titleElement.textContent = title;
            if (messageElement) messageElement.textContent = message;

            modal.classList.add('active');

            // Auto-close after 5 seconds if no close button interaction
            setTimeout(() => {
                if (modal.classList.contains('active')) {
                    closeModal('message-modal');
                }
            }, 5000);
        }

        // Generic close modal function
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('active');
            }
        }

        // Function to open a modal by ID
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('active');
            }
        }

        // Function to close a modal by ID
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('active');
            }
        }


        // === NEW: Referral System Functions ===
        function generateReferralLink() {
            if (!tgUser || !tgUser.id) return '';
            // In Telegram Mini Apps, deep linking is done via the bot's username and start parameter
            // Example: https://t.me/your_bot_username?start=ref_123456789
            // The 'ref_123456789' part is what the invited user sends to the bot.
            // The bot backend (e.g., BotFather webhook) needs to handle the '/start ref_123456789' command.
            // Here we just generate the link for the user to share.
            const botUsername = "TKBD5_bot"; // Replace with your actual bot username
            return `https://t.me/${botUsername}?start=ref_${tgUser.id}`;
        }

        function copyReferralLink() {
            const referralLink = generateReferralLink();
            if (referralLink) {
                navigator.clipboard.writeText(referralLink).then(() => {
                    showMessageModal('Copied!', 'Referral link copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy referral link: ', err);
                    // Fallback: show the link in an alert or prompt
                    prompt("Copy this referral link:", referralLink);
                });
            }
        }

        async function checkForReferral() {
            // This function would ideally be called when the app initializes.
            // It needs to check if the app was opened via a referral link.
            // Telegram WebApp provides `initDataUnsafe.start_param` for this.
            const startParam = Telegram.WebApp.initDataUnsafe?.start_param;

            if (startParam && startParam.startsWith('ref_')) {
                const referrerId = startParam.substring(4); // Remove 'ref_' prefix
                if (referrerId && referrerId !== tgUser.id.toString()) { // Ensure user doesn't refer themselves
                    try {
                        const referrerRef = database.ref('users/' + referrerId);
                        const referrerSnapshot = await referrerRef.once('value');
                        const referrerData = referrerSnapshot.val();

                        if (referrerData) {
                            // Check if this user was already referred by this person (prevent duplicate rewards)
                            // We can store the referrerId who referred this user in their own data
                            const userRef = database.ref('users/' + tgUser.id);
                            const userSnapshot = await userRef.once('value');
                            const userData = userSnapshot.val();

                            if (userData && !userData.referrerId) { // Only if not already referred
                                // Update referrer's count and earnings
                                const newReferralCount = (referrerData.referralCount || 0) + 1;
                                const referralReward = appConfig.referralRewardCoins; // Get from config
                                const newReferralEarnings = (referrerData.referralEarnings || 0) + referralReward;

                                await referrerRef.update({
                                    referralCount: newReferralCount,
                                    referralEarnings: newReferralEarnings
                                });

                                // Update current user's data to mark who referred them
                                await userRef.update({
                                    referrerId: parseInt(referrerId), // Store as number if IDs are numbers
                                    referredBy: referrerData.username || referrerData.firstName || `User ${referrerId}` // Store name for display
                                });

                                // Update local state for referrer (if this user *is* the referrer, unlikely here)
                                if (tgUser.id.toString() === referrerId) {
                                    referralData.referralCount = newReferralCount;
                                    referralData.referralEarnings = newReferralEarnings;
                                }

                                // Add reward to referrer's points and balance
                                let referrerNewPoints = (referrerData.points || 0) + referralReward;
                                let referrerNewBalance = referrerNewPoints / appConfig.coinsForConversion * appConfig.valuePerConversion;

                                await updateUserBalanceAndPoints(
                                    referrerRef,
                                    referrerNewPoints,
                                    referrerNewBalance,
                                    `+${referralReward} coins from referral of User ${tgUser.id}`
                                );

                                showMessageModal('Referral Success!', `You were successfully referred by User ${referrerId}. They received a reward!`);

                                // Update current user's local data to reflect referral
                                // This happens in loadUserData on the next load, or we can update local state here if needed
                                // For now, assume next load will pick it up.
                            } else {
                                console.log("User was already referred or referrer data not found.");
                            }
                        } else {
                            console.log("Referrer not found in database.");
                        }
                    } catch (error) {
                        console.error("Error processing referral:", error);
                        showMessageModal('Error', 'Failed to process referral. Please try again.');
                    }
                } else {
                    console.log("Invalid or self-referral attempt.");
                }
            } else {
                // console.log("No referral start_param found or invalid format.");
            }
        }


        // === NEW: VIP Package Functions ===
        async function loadVipPackages() {
            try {
                const snapshot = await database.ref('vipPackages').once('value');
                const packages = snapshot.val();
                vipPackages = packages ? Object.entries(packages).map(([id, data]) => ({ id, ...data })) : [];
                renderVipPackages();
            } catch (error) {
                console.error("Failed to load VIP packages:", error);
                document.getElementById('vip-packages-list').innerHTML = '<p class="error-message">Failed to load packages.</p>';
            }
        }

        async function loadUserVipSubscriptions() {
            if (!tgUser || !tgUser.id) return;
            try {
                const snapshot = await database.ref('users/' + tgUser.id + '/vipSubscriptions').once('value');
                userVipSubscriptions = snapshot.val() || {};
                renderVipPackages(); // Update UI based on loaded subscriptions
            } catch (error) {
                console.error("Failed to load user VIP subscriptions:", error);
                // Optionally update UI to show error or default state
            }
        }

        function renderVipPackages() {
            const container = document.getElementById('vip-packages-list');
            if (!container) return;

            if (vipPackages.length === 0) {
                container.innerHTML = '<p class="text-muted">No VIP packages available at the moment.</p>';
                return;
            }

            container.innerHTML = vipPackages.map(pkg => {
                const userSub = userVipSubscriptions[pkg.id];
                const now = new Date();
                const isSubscribed = userSub && userSub.status === 'Active';
                const isPending = userSub && userSub.status === 'Pending';
                const isExpired = userSub && userSub.status === 'Expired';
                const isWithinPeriod = userSub && userSub.endDate && new Date(userSub.endDate) > now;

                let buttonHtml = '';
                let statusHtml = '';
                let timerHtml = '';

                if (isPending) {
                    buttonHtml = '<button class="buy-button" disabled>Pending...</button>';
                    statusHtml = '<div class="vip-package-status">Status: Pending Approval</div>';
                } else if (isSubscribed && isWithinPeriod) {
                    // Active subscription
                    statusHtml = '<div class="vip-package-status">Status: Active</div>';
                    // Check daily limit
                    const today = now.toDateString();
                    const lastWatchDate = userSub.lastVideoWatchTime ? new Date(userSub.lastVideoWatchTime).toDateString() : null;
                    const videosToday = userSub.videosWatchedToday || 0;
                    const dailyLimit = userSub.dailyVideoLimit || pkg.dailyVideoLimit || 0;

                    if (today === lastWatchDate && videosToday >= dailyLimit) {
                        buttonHtml = '<button class="vip-watch-button" disabled>Daily Limit Reached</button>';
                        // Optional: Show reset timer
                        const nextReset = new Date(now);
                        nextReset.setHours(24, 0, 0, 0); // Reset at next midnight
                        const timeUntilReset = nextReset - now;
                        if (timeUntilReset > 0) {
                             const hours = Math.floor(timeUntilReset / (1000 * 60 * 60));
                             const minutes = Math.floor((timeUntilReset % (1000 * 60 * 60)) / (1000 * 60));
                             timerHtml = `<div class="vip-package-status">Timer: ${hours}h ${minutes}m until reset</div>`;
                        }
                    } else {
                        buttonHtml = `<button class="vip-watch-button" onclick="watchVipVideo('${pkg.id}')">Watch VIP Ad (${dailyLimit - videosToday} left today)</button>`;
                    }
                } else if (isExpired || !isWithinPeriod) {
                    // Expired or no active sub
                    buttonHtml = `<button class="buy-button" onclick="buyVipPackage('${pkg.id}', ${pkg.price})">Buy - $${pkg.price.toFixed(2)}</button>`;
                    statusHtml = '<div class="vip-package-status">Status: Not Subscribed</div>';
                } else {
                    // Inactive but not expired yet (shouldn't happen with current logic, but safe check)
                    buttonHtml = `<button class="buy-button" onclick="buyVipPackage('${pkg.id}', ${pkg.price})">Buy - $${pkg.price.toFixed(2)}</button>`;
                    statusHtml = '<div class="vip-package-status">Status: Inactive</div>';
                }

                return `
                    <div class="vip-package-card">
                        <div class="vip-package-title">${pkg.name}</div>
                        <div class="vip-package-price">$${pkg.price.toFixed(2)}</div>
                        <div class="vip-package-benefits">${pkg.description}</div>
                        ${statusHtml}
                        ${timerHtml}
                        ${buttonHtml}
                    </div>
                `;
            }).join('');
        }

        async function buyVipPackage(packageId, price) {
            if (isBlocked) {
                showBlockedView();
                return;
            }

            if (balance < price) {
                showMessageModal('Insufficient Funds', `You need $${price.toFixed(2)} to buy this VIP package. Your current balance is $${balance.toFixed(2)}.`);
                return;
            }

            // Deduct balance
            balance -= price;
            // Recalculate points based on new balance
            points = Math.max(0, Math.round(balance / appConfig.valuePerConversion * appConfig.coinsForConversion));

            const userRef = database.ref('users/' + tgUser.id);
            const packageRef = database.ref('vipPackages/' + packageId);

            try {
                // Get package details to calculate end date
                const pkgSnapshot = await packageRef.once('value');
                const pkgData = pkgSnapshot.val();
                if (!pkgData) {
                    throw new Error("Package not found");
                }

                const now = new Date();
                // Calculate end date based on package duration (assuming duration is in days)
                const endDate = new Date(now);
                endDate.setDate(endDate.getDate() + (pkgData.durationInDays || 30)); // Default 30 days

                // Update user's VIP subscription data
                await userRef.child('vipSubscriptions').update({
                    [packageId]: {
                        packageId: packageId,
                        packageName: pkgData.name,
                        price: price,
                        startDate: now.toISOString(),
                        endDate: endDate.toISOString(),
                        status: 'Pending', // Initially pending until admin approves
                        dailyVideoLimit: pkgData.dailyVideoLimit || 5, // Default limit
                        videosWatchedToday: 0,
                        lastVideoWatchTime: null
                    }
                });

                // Update user's balance and points in Firebase
                await updateUserBalanceAndPoints(
                    userRef,
                    points,
                    balance,
                    `Purchased VIP package: ${pkgData.name} for $${price.toFixed(2)}`
                );

                // Reload user subscriptions to reflect the pending state
                await loadUserVipSubscriptions();

                showMessageModal('Purchase Pending', `Your VIP package purchase for $${price.toFixed(2)} is pending admin approval. Check back soon!`);

            } catch (error) {
                console.error("Error purchasing VIP package:", error);
                // Revert balance change on error
                balance += price;
                points = Math.max(0, Math.round(balance / appConfig.valuePerConversion * appConfig.coinsForConversion));
                showMessageModal('Error', 'Failed to process VIP package purchase. Please try again.');
            }
        }


        // === NEW: Watch VIP Video Function ===
        async function watchVipVideo(packageId) {
            if (!tgUser || !tgUser.id || !packageId) return;

            const userSub = userVipSubscriptions[packageId];
            if (!userSub || userSub.status !== 'Active') {
                 showMessageModal('Error', 'Your VIP subscription for this package is not active.');
                 return;
            }

            const now = new Date();
            const today = now.toDateString();
            const isWithinPeriod = new Date(userSub.endDate) > now;

            if (!isWithinPeriod) {
                showMessageModal('Error', 'Your VIP subscription for this package has expired.');
                // Optionally reload subscriptions to update status
                await loadUserVipSubscriptions();
                return;
            }

            // Check daily limit
            const lastWatchDate = userSub.lastVideoWatchTime ? new Date(userSub.lastVideoWatchTime).toDateString() : null;
            const videosToday = userSub.videosWatchedToday || 0;
            const dailyLimit = userSub.dailyVideoLimit;

            if (today === lastWatchDate && videosToday >= dailyLimit) {
                showMessageModal('Error', `You have reached your daily video limit of ${dailyLimit} for this VIP package. Please wait for the timer to reset.`);
                return;
            }

            // Check if the Monetag SDK function is available (use a specific zone for VIP ads if needed)
            // For now, using the same as main ads
            if (typeof show_9807992 === 'function') { // Assuming same function or a specific VIP one like show_vip_ad()
                // Prevent double click by disabling the button immediately
                const watchBtn = event.currentTarget; // Get the clicked watch button
                if (watchBtn.classList.contains('disabled')) {
                     console.log("Button already disabled, ignoring click.");
                     return;
                }
                watchBtn.classList.add('disabled');
                watchBtn.textContent = 'Loading...';

                 // Attempt to show the ad using Monetag SDK function
                 show_9807992() // Use appropriate VIP ad function if different
                     .then(async (result) => {
                         console.log("VIP Ad result:", result);
                         if (result && (result.watched === true || result.status === 'completed')) {
                             // Calculate reward (could be different for VIP)
                             const coinsEarned = appConfig.pointsPerAd * 2; // Example: 2x reward for VIP
                             balance += (coinsEarned / appConfig.coinsForConversion) * appConfig.valuePerConversion;
                             points += coinsEarned;

                             const userRef = database.ref('users/' + tgUser.id);

                             // Update user's balance and points
                             await updateUserBalanceAndPoints(
                                 userRef,
                                 points,
                                 balance,
                                 `+${coinsEarned} coins from watching a VIP ad`
                             );

                             showMessageModal('Success', `Congratulations! You've earned +${coinsEarned} coins from the VIP ad. Your new balance is $${balance.toFixed(2)}.`);

                             // Update VIP tracking data
                             await updateVipAdTracking(packageId);
                         } else {
                             console.log("VIP Ad was not completed or skipped.");
                             showMessageModal('Info', 'VIP Ad was not completed. No reward given.');
                         }
                         watchBtn.classList.remove('disabled');
                         watchBtn.textContent = 'Watch VIP Ad'; // Reset text just in case
                         renderVipPackages(); // Update UI counters immediately
                     })
                     .catch(async (error) => {
                         // Handle errors, e.g., ad failed to load
                         console.error("VIP Ad could not be shown:", error);
                         showMessageModal('Error', "Sorry, the VIP ad could not be loaded. Please try again.");
                         // Re-enable the button on error
                         watchBtn.classList.remove('disabled');
                         watchBtn.textContent = 'Watch VIP Ad';
                     });
            } else {
                // SDK not loaded or function not available
                console.warn("Monetag SDK for VIP ads is not ready yet.");
                showMessageModal('Error', "Ad service is not ready. Please try again later.");
            }
        }

        // Function to update VIP ad tracking data in Firebase
        async function updateVipAdTracking(packageId) {
            if (!tgUser || !tgUser.id || !packageId) return;

            const userRef = database.ref('users/' + tgUser.id);
            const now = new Date();
            const today = now.toDateString();

            try {
                // Get current subscription data
                const subSnapshot = await userRef.child(`vipSubscriptions/${packageId}`).once('value');
                const subData = subSnapshot.val();
                if (!subData) {
                    console.error(`Subscription data for package ${packageId} not found.`);
                    return;
                }

                let videosToday = subData.videosWatchedToday || 0;
                const lastWatchDate = subData.lastVideoWatchTime ? new Date(subData.lastVideoWatchTime).toDateString() : null;

                 // If it's a new day, reset the count
                 if (lastWatchDate !== today) {
                     videosToday = 0;
                 }
                 videosToday += 1; // Increment for this watch

                 // Update Firebase
                 await userRef.child(`vipSubscriptions/${packageId}`).update({
                     videosWatchedToday: videosToday,
                     lastVideoWatchTime: now.toISOString()
                 });

                 // Update local state
                 userVipSubscriptions[packageId].videosWatchedToday = videosToday;
                 userVipSubscriptions[packageId].lastVideoWatchTime = now.toISOString();

                 // No need to reload all subscriptions for this single update
                 renderVipPackages(); // Update the UI immediately to show reset
            } catch (error) {
                console.error(`Failed to update VIP counter for package ${packageId}:`, error);
            }
        }


        // === NEW: Background Update for VIP Data ===
        function startVipUpdateInterval() {
            if (vipUpdateInterval) {
                clearInterval(vipUpdateInterval);
            }
            vipUpdateInterval = setInterval(() => {
                // This function runs every second in the background
                const now = new Date();
                let subscriptionChanged = false;

                for (const [pkgId, subData] of Object.entries(userVipSubscriptions)) {
                    if (subData.status === 'Active' && new Date(subData.endDate) <= now) {
                        // Subscription expired
                        userVipSubscriptions[pkgId].status = 'Expired';
                        subscriptionChanged = true;
                        console.log(`Subscription for package ${pkgId} has expired.`);
                    }

                    // Check for daily reset (at midnight)
                    const lastWatchDate = subData.lastVideoWatchTime ? new Date(subData.lastVideoWatchTime).toDateString() : null;
                    if (lastWatchDate && lastWatchDate !== now.toDateString()) {
                        // New day, reset video count
                        userVipSubscriptions[pkgId].videosWatchedToday = 0;
                        userVipSubscriptions[pkgId].lastVideoWatchTime = null; // Or set to start of today?
                        subscriptionChanged = true;
                        console.log(`Daily video count reset for package ${pkgId}.`);
                    }
                }

                if (subscriptionChanged) {
                    // Update UI to reflect changes (expired subs, reset counters)
                    renderVipPackages();
                    // Potentially save changes back to Firebase if status changed, though listeners usually handle that
                }

            }, 1000); // Run every second
        }


        // === NEW: Real-time Listeners ===
        let blockingListener = null;
        let withdrawHistoryListener = null;
        let userPointsBalanceListener = null;
        let referralListener = null;
        let appConfigListener = null;
        let userAdDataListener = null; // New listener for ad data

        function setupBlockingListener(userRef) {
            if (blockingListener) {
                userRef.child('isBlocked').off('value', blockingListener);
            }
            blockingListener = userRef.child('isBlocked').on('value', (snapshot) => {
                const isUserBlocked = snapshot.val() || false;
                if (isUserBlocked !== isBlocked) {
                    isBlocked = isUserBlocked;
                    if (isBlocked) {
                        showBlockedView();
                    } else {
                        // If unblocked, maybe show the home view or the view they were on
                        // For now, show home
                        showView('home-view');
                    }
                }
            });
        }

        function setupWithdrawHistoryListener(userRef) {
            if (withdrawHistoryListener) {
                userRef.child('withdrawHistory').off('value', withdrawHistoryListener);
            }
            withdrawHistoryListener = userRef.child('withdrawHistory').on('value', (snapshot) => {
                const history = snapshot.val();
                withdrawHistory = history ? Object.values(history) : [];
                // Optionally update UI elements that show withdraw request count/status
                // e.g., update a badge on the withdraw navigation item
            });
        }

        function setupPointsBalanceListener(userRef) {
            if (userPointsBalanceListener) {
                userRef.off('value', userPointsBalanceListener); // Listen to root user data
            }
            userPointsBalanceListener = userRef.on('value', (snapshot) => {
                const userData = snapshot.val();
                if (userData) {
                    // Update points and balance if they changed
                    if (userData.points !== undefined && userData.points !== points) {
                        points = userData.points;
                    }
                    if (userData.balance !== undefined && userData.balance !== balance) {
                        balance = userData.balance;
                    }
                    // Update ad tracking related data
                    if (userData.adsWatchedToday !== undefined || userData.lastAdWatchTime !== undefined) {
                        // Update local ad tracking state
                        const newAdsToday = userData.adsWatchedToday || 0;
                        const newLastAdTime = userData.lastAdWatchTime ? new Date(userData.lastAdWatchTime) : null;

                        if (newAdsToday !== (lastAdWatchTime ? (new Date(lastAdWatchTime).toDateString() === new Date().toDateString() ? userData.adsWatchedToday : 0) : 0) ||
                            newLastAdTime?.toDateString() !== (lastAdWatchTime?.toDateString())) {
                            lastAdWatchTime = newLastAdTime;
                            // Update button states based on new data
                            updateAdButtonStates(userData);
                        }
                    }
                    updateDisplay();
                }
            });
        }

        function setupReferralListener(userRef) {
            if (referralListener) {
                userRef.child('referralCount').off('value', referralListener);
                userRef.child('referralEarnings').off('value', referralListener);
            }
            // Set up new listeners for referral data
            referralListener = userRef.on('value', (snapshot) => {
                const userData = snapshot.val();
                if (userData) {
                    referralData.referralCount = userData.referralCount || 0;
                    referralData.referralEarnings = userData.referralEarnings || 0;

                    // Update share modal if it's open
                    if (document.getElementById('share-modal').classList.contains('active')) {
                        updateShareModal();
                    }

                    // Check if referral earnings reached threshold (from Firebase config)
                    if (referralData.referralEarnings >= appConfig.referralClaimThreshold) {
                         // Optionally, highlight a "Claim Earnings" button or show a notification
                         console.log("Referral earnings threshold reached!");
                         // Example: Show a button or modal
                         // showMessageModal('Earnings Ready', `You have $${(referralData.referralEarnings / appConfig.coinsForConversion * appConfig.valuePerConversion).toFixed(2)} in referral earnings ready to claim!`);
                         // Or update a specific UI element
                         const claimButton = document.getElementById('claim-earnings-btn');
                         if (claimButton) {
                             claimButton.style.display = 'block'; // Make it visible
                         }
                    }
                }
            });
        }

        function setupAppConfigListener() {
            if (appConfigListener) {
                database.ref('appConfig').off('value', appConfigListener);
            }
            appConfigListener = database.ref('appConfig').on('value', (snapshot) => {
                const config = snapshot.val();
                if (config) {
                    // Store old values to check for changes
                    const oldBalanceCardBg = appConfig.balanceCardBgColor; // Use the new color config
                    const oldDepositInstrText = appConfig.depositInstructionText;
                    const oldDepositNumber = appConfig.depositNumber;
                    const oldDepositInstrBgColor = appConfig.depositInstructionBgColor;
                    const oldDepositInstrTextColor = appConfig.depositInstructionTextColor;
                    const oldDepositNumberColor = appConfig.depositNumberColor;
                    const oldPrimaryColor = appConfig.primaryColor; // Store old primary color

                    // Update config with new values
                    appConfig = {
                        ...appConfig, // Spread existing config
                        pointsPerAd: config.pointsPerAd !== undefined ? config.pointsPerAd : appConfig.pointsPerAd,
                        coinsForConversion: config.coinsForConversion !== undefined ? config.coinsForConversion : appConfig.coinsForConversion,
                        valuePerConversion: config.valuePerConversion !== undefined ? config.valuePerConversion : appConfig.valuePerConversion,
                        referralRewardCoins: config.referralRewardCoins !== undefined ? config.referralRewardCoins : appConfig.referralRewardCoins,
                        referralClaimThreshold: config.referralClaimThreshold !== undefined ? config.referralClaimThreshold : appConfig.referralClaimThreshold,
                        minWithdrawAmount: config.minWithdrawAmount !== undefined ? config.minWithdrawAmount : appConfig.minWithdrawAmount,
                        dailyAdLimitPerUser: config.dailyAdLimitPerUser !== undefined ? config.dailyAdLimitPerUser : appConfig.dailyAdLimitPerUser,
                        isAdSystemActive: config.isAdSystemActive !== undefined ? config.isAdSystemActive : appConfig.isAdSystemActive,
                        usdToBdtRate: config.usdToBdtRate !== undefined ? config.usdToBdtRate : appConfig.usdToBdtRate,
                        // Update the new color configs
                        balanceCardBgColor: config.balanceCardBgColor || appConfig.balanceCardBgColor,
                        depositInstructionText: config.depositInstructionText || appConfig.depositInstructionText,
                        depositNumber: config.depositNumber || appConfig.depositNumber,
                        depositInstructionBgColor: config.depositInstructionBgColor || appConfig.depositInstructionBgColor,
                        depositInstructionTextColor: config.depositInstructionTextColor || appConfig.depositInstructionTextColor,
                        depositNumberColor: config.depositNumberColor || appConfig.depositNumberColor,
                        primaryColor: config.primaryColor || appConfig.primaryColor // Load new primary color
                    };

                    // Check if balance card background changed (using new color)
                    if (oldBalanceCardBg !== appConfig.balanceCardBgColor) {
                        const balanceCard = document.querySelector('.balance-card');
                        if (balanceCard) {
                            // Apply the new solid color
                            balanceCard.style.background = appConfig.balanceCardBgColor;
                        }
                    }

                    // If deposit instruction text or number changed, update the deposit modal
                    if (oldDepositInstrText !== appConfig.depositInstructionText || oldDepositNumber !== appConfig.depositNumber) {
                        const instrTextElement = document.getElementById('deposit-instruction-text');
                        const numberElement = document.getElementById('deposit-number');
                        if (instrTextElement) {
                            instrTextElement.textContent = appConfig.depositInstructionText;
                        }
                        if (numberElement) {
                            numberElement.textContent = appConfig.depositNumber;
                        }
                    }

                    // If deposit instruction colors changed, update the deposit modal
                    if (oldDepositInstrBgColor !== appConfig.depositInstructionBgColor ||
                        oldDepositInstrTextColor !== appConfig.depositInstructionTextColor ||
                        oldDepositNumberColor !== appConfig.depositNumberColor) {
                        const depositInstructionsElement = document.getElementById('deposit-instructions');
                        if (depositInstructionsElement) {
                            depositInstructionsElement.style.backgroundColor = appConfig.depositInstructionBgColor;
                            // Update text color if needed, but often it's better to rely on CSS contrast
                            // depositInstructionsElement.style.color = appConfig.depositInstructionTextColor;
                        }
                        const numberElement = document.getElementById('deposit-number');
                        if (numberElement) {
                            numberElement.style.color = appConfig.depositNumberColor;
                        }
                    }

                    // Check if primary color changed and update dynamic colors
                    if (oldPrimaryColor !== appConfig.primaryColor) {
                        console.log("Primary color changed in config, updating dynamic colors.");
                        updateDynamicColors(); // Call the function to update CSS variables
                    }

                } else {
                    console.log("App config updated to null, using defaults.");
                    // Potentially reset to defaults if config is removed, though unlikely
                }
            });
        }


        function setupUserAdDataListener(userRef) {
            if (userAdDataListener) {
                userRef.child('adsWatchedToday').off('value', userAdDataListener);
                userRef.child('lastAdWatchTime').off('value', userAdDataListener);
            }
            // Listen specifically to ad-related data to update button states
            userAdDataListener = userRef.on('value', (snapshot) => {
                const userData = snapshot.val();
                if (userData) {
                    updateAdButtonStates(userData);
                }
            });
        }


        // Function to render the leaderboard (example data, replace with actual Firebase query)
        async function renderLeaderboard() {
            // This is a simplified version. A real leaderboard would require a server-side query
            // to rank users by balance or earnings, potentially limited to top N.
            // For now, we'll simulate fetching top users.
            try {
                // Example query: Get top 10 users by balance
                // Note: Firebase Realtime DB doesn't support complex queries like SQL.
                // You might need to structure data differently or use Cloud Functions for true leaderboard logic.
                // This example fetches all users (not scalable) and sorts client-side.
                // DO NOT USE THIS FOR PRODUCTION WITH MANY USERS.
                /*
                const snapshot = await database.ref('users').orderByChild('balance').limitToLast(10).once('value');
                const allUsers = snapshot.val();
                let leaderboardUsers = [];
                if (allUsers) {
                    leaderboardUsers = Object.values(allUsers)
                        .sort((a, b) => b.balance - a.balance) // Sort descending by balance
                        .slice(0, 10); // Top 10
                }
                */

                // Simulated leaderboard data for demo
                const leaderboardUsers = [
                    { firstName: 'Alice', balance: 150.75 },
                    { firstName: 'Bob', balance: 120.50 },
                    { firstName: 'Charlie', balance: 99.99 },
                    { firstName: 'You', balance: balance } // Add current user
                ].sort((a, b) => b.balance - a.balance);

                const leaderboardContainer = document.getElementById('leaderboard-list');
                if (!leaderboardContainer) return;

                // Find current user's rank
                const userRank = leaderboardUsers.findIndex(u => u.firstName === 'You') + 1;

                leaderboardContainer.innerHTML = leaderboardUsers.map((user, index) => {
                    const isCurrentUser = user.firstName === 'You';
                    return `
                        <div class="leaderboard-item ${isCurrentUser ? 'current-user' : ''}">
                            <span class="leaderboard-rank">#${index + 1}</span>
                            <span class="leaderboard-name">${user.firstName}</span>
                            <span class="leaderboard-earnings">$${user.balance.toFixed(2)}</span>
                        </div>
                    `;
                }).join('');

                // Optionally, highlight the user's rank elsewhere
                const userRankElement = document.getElementById('user-rank');
                if (userRankElement && userRank > 0) {
                    userRankElement.textContent = `Your Rank: #${userRank}`;
                }

            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                const leaderboardContainer = document.getElementById('leaderboard-list');
                if (leaderboardContainer) {
                    leaderboardContainer.innerHTML = '<p class="error-message">Failed to load leaderboard.</p>';
                }
            }
        }


        // - Withdrawal Logic -
        // Flag to prevent multiple withdrawal requests
        let isWithdrawRequestPending = false;

        function requestWithdraw() {
            if (isBlocked) {
                showBlockedView();
                return;
            }

            // Prevent multiple simultaneous requests using flag
            if (isWithdrawRequestPending) {
                console.log("Withdrawal request already in progress.");
                return;
            }

            // Validation
            const paymentMethod = document.getElementById('paymentMethod').value;
            const mobileNumber = document.getElementById('mobileNumber').value.trim();
            let amountInput = document.getElementById('withdrawAmount').value;
            let amount = parseFloat(amountInput);

            if (!mobileNumber) {
                showMessageModal('Error', 'Please enter your mobile number.');
                return;
            }
            if (!amount || isNaN(amount)) {
                showMessageModal('Error', 'Please enter a valid amount.');
                return;
            }
            if (amount < appConfig.minWithdrawAmount) {
                showMessageModal('Error', `Minimum withdrawal amount is $${appConfig.minWithdrawAmount.toFixed(2)}.`);
                return;
            }
            if (amount > balance) {
                showMessageModal('Error', 'Insufficient balance for this withdrawal.');
                return;
            }

            // Check for existing pending/processing requests in local array
            const hasPendingRequest = withdrawHistory.some(request =>
                request.status === 'Pending' || request.status === 'Processing'
            );
            if (hasPendingRequest) {
                showMessageModal('Error', 'You already have a pending or processing withdrawal request. Please wait for it to be completed before submitting a new one.');
                return;
            }

            // Set flag to indicate a request is in progress
            isWithdrawRequestPending = true;

            // Change button to red "Requesting..." state immediately
            const requestBtn = document.getElementById('requestWithdrawBtn');
            requestBtn.textContent = 'Requesting...';
            requestBtn.classList.remove('primary-button');
            requestBtn.classList.add('secondary-button'); // Or a specific requesting class
            requestBtn.disabled = true;

            // Prepare withdrawal request object
            const withdrawRequest = {
                id: Date.now().toString(), // Use timestamp as a simple ID
                amount: amount,
                paymentMethod: paymentMethod,
                mobileNumber: mobileNumber,
                timestamp: new Date().toISOString(),
                status: 'Pending', // Default status
                userId: tgUser.id, // Include user ID for admin reference
                userName: tgUser.first_name || tgUser.username || 'Unknown' // Include user name
            };

            const userRef = database.ref('users/' + tgUser.id);

            // Immediately deduct balance and update points in Firebase AND locally
            // This deduction happens immediately when the request is submitted
            balance -= amount;
            // Ensure points are calculated correctly and don't go negative
            points = Math.max(0, Math.round(balance / appConfig.valuePerConversion * appConfig.coinsForConversion));
            updateDisplay();
            saveUserData(); // Save immediately to prevent loss if page reloads

            // Add to local withdrawHistory array for immediate display in modal if open
            withdrawHistory.unshift(withdrawRequest);
            if (document.getElementById('withdraw-history-modal').classList.contains('active')) {
                renderWithdrawHistoryModal();
            }

            // Send request to Firebase
            userRef.child('withdrawHistory').push(withdrawRequest)
                .then(() => {
                    console.log("Withdrawal request sent to Firebase successfully.");
                    showMessageModal('Request Sent', `Your withdrawal request for $${amount.toFixed(2)} has been sent successfully. Status: Pending.`);
                    // Optionally close the modal after a delay
                    // setTimeout(() => { closeModal('withdraw-modal'); }, 3000);
                })
                .catch((error) => {
                    console.error("Error sending withdrawal request to Firebase:", error);
                    // Revert the balance deduction on failure
                    balance += amount;
                    points = Math.max(0, Math.round(balance / appConfig.valuePerConversion * appConfig.coinsForConversion));
                    updateDisplay();
                    saveUserData(); // Save the reverted state
                    showMessageModal('Error', 'Failed to send withdrawal request. Please try again.');
                })
                .finally(() => {
                    // Reset flag and button state regardless of success or failure
                    isWithdrawRequestPending = false;
                    if (requestBtn) { // Check if button still exists
                        requestBtn.textContent = 'Request Withdrawal';
                        requestBtn.classList.remove('secondary-button');
                        requestBtn.classList.add('primary-button');
                        requestBtn.disabled = false;
                    }
                });
        }


        // Function to handle deposit request
        async function requestDeposit() {
            if (isBlocked) {
                showBlockedView();
                return;
            }

            const amountInput = document.getElementById('depositAmount').value;
            const amount = parseFloat(amountInput);

            if (!amount || isNaN(amount) || amount <= 0) {
                showMessageModal('Error', 'Please enter a valid deposit amount.');
                return;
            }

            // Prepare deposit request object
            const depositRequest = {
                id: Date.now().toString(),
                amount: amount,
                timestamp: new Date().toISOString(),
                status: 'Pending', // Default status for admin review
                userId: tgUser.id,
                userName: tgUser.first_name || tgUser.username || 'Unknown'
            };

            const userRef = database.ref('users/' + tgUser.id);

            try {
                // Send request to a specific node for admin review, e.g., 'depositRequests'
                // It's better to store deposit requests separately from user data for admin management
                await database.ref('depositRequests').push(depositRequest);

                // Optionally, add a reference to the request ID in the user's data
                // await userRef.child('lastDepositRequestId').set(depositRequest.id);

                // Update local history (optional, maybe just show a success message)
                // historyLog.unshift({
                //     id: Date.now(),
                //     detail: `Deposit request submitted for $${amount.toFixed(2)}`,
                //     type: 'deposit_request',
                //     timestamp: new Date().toISOString()
                // });
                // renderHistoryList(); // Update history list

                showMessageModal('Success', 'Deposit request submitted! Admin will review it shortly.');
            } catch (error) {
                console.error("Error submitting deposit request:", error);
                showMessageModal('Error', 'Failed to submit request. Please try again.');
            }
        }


        // === NEW: Chat System Functions (Simplified) ===
        // This is a basic example, a full chat requires more complex backend logic for real-time messaging between users/admins.
        // For a bot, it's often better to use Telegram's native messaging or commands.

        function sendMessageToAdmin() {
            const input = document.getElementById('admin-message-input');
            const messageText = input.value.trim();

            if (!messageText) return;

            // In a real app, you'd send this message via a bot command or webhook to the admin.
            // For example, send a message like: `/chat_user_123456789 Hello admin!`
            // The bot backend would parse this and forward to admin chat interface.
            // Here, we'll just clear the input and show a message.
            console.log(`User ${tgUser.id} sent message to admin:`, messageText);
            input.value = '';

            // Example: Send via Telegram bot command (requires backend handling)
            // const botToken = 'YOUR_BOT_TOKEN';
            // const adminChatId = 'ADMIN_CHAT_ID';
            // const text = encodeURIComponent(`/chat_user_${tgUser.id} ${messageText}`);
            // fetch(`https://api.telegram.org/bot${botToken}/sendMessage?chat_id=${adminChatId}&text=${text}`)
            //     .then(response => response.json())
            //     .then(data => console.log('Message sent:', data))
            //     .catch(err => console.error('Error sending message:', err));

            showMessageModal('Message Sent', 'Your message has been sent to the admin.');
        }


        // === NEW: Notification System (Simplified) ===
        // Notifications can be fetched from a Firebase node and displayed.
        async function loadNotifications() {
            try {
                // Example: Fetch important notices from a specific node
                const snapshot = await database.ref('importantNotices').orderByChild('timestamp').limitToLast(5).once('value');
                const notices = snapshot.val();

                const noticesListElement = document.getElementById('important-notices-list');
                if (!noticesListElement) return;

                if (!notices || Object.keys(notices).length === 0) {
                    noticesListElement.innerHTML = '<p class="text-muted">No important notices at the moment.</p>';
                    return;
                }

                // Convert object to array and sort by timestamp (newest first)
                const noticesArray = Object.entries(notices)
                    .map(([id, data]) => ({ id, ...data }))
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // Sort descending

                noticesListElement.innerHTML = noticesArray.map(notice => `
                    <div class="notification-item">
                        <h4>${notice.title || 'Notice'}</h4>
                        <p>${notice.message || 'No message content.'}</p>
                        <small class="text-muted">${new Date(notice.timestamp).toLocaleString()}</small>
                    </div>
                `).join('');
            } catch (error) {
                console.error("Error loading notifications:", error);
                const noticesListElement = document.getElementById('important-notices-list');
                if (noticesListElement) {
                    noticesListElement.innerHTML = '<p class="error-message">Failed to load notices.</p>';
                }
            }
        }

        function openNotificationsModal() {
            loadNotifications(); // Load notifications when modal opens
            openModal('notifications-modal');
        }


        // Initialize the app when the page loads
        window.onload = function() {
            initApp();
        };

        // Example: Attach event listeners for navigation, modals, etc.
        // This part depends on your specific HTML structure.
        // Example:
        document.addEventListener('DOMContentLoaded', (event) => {
            // Attach ad button listener
            const adButton = document.getElementById('watch-ad-button');
            if (adButton) {
                adButton.addEventListener('click', handleAdButtonClick);
            }

            // Attach withdraw button listener
            const withdrawButton = document.getElementById('requestWithdrawBtn');
            if (withdrawButton) {
                withdrawButton.addEventListener('click', requestWithdraw);
            }

            // Attach deposit button listener
            const depositButton = document.getElementById('requestDepositBtn');
            if (depositButton) {
                depositButton.addEventListener('click', requestDeposit);
            }

            // Attach send message listener
            const sendMessageButton = document.getElementById('send-admin-message');
            if (sendMessageButton) {
                sendMessageButton.addEventListener('click', sendMessageToAdmin);
            }

            // Pressing Enter in the message input should also send the message
            const messageInput = document.getElementById('admin-message-input');
            if (messageInput) {
                messageInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendMessageToAdmin();
                    }
                });
            }

            // Close modals when clicking the close button or overlay
            document.querySelectorAll('.close-modal, .modal').forEach(element => {
                element.addEventListener('click', function(e) {
                    if (e.target === this || this.classList.contains('close-modal')) {
                        // Find the closest modal and close it
                        let modal = this;
                        if (!modal.classList.contains('modal')) {
                            modal = this.closest('.modal');
                        }
                        if (modal) {
                            modal.classList.remove('active');
                        }
                    }
                });
            });

             // Example: Navigation listeners (attach to nav items in your HTML)
             /*
             document.querySelectorAll('.nav-item').forEach(item => {
                 item.addEventListener('click', function(e) {
                     e.preventDefault(); // Prevent default anchor behavior if using <a> tags
                     const targetView = this.getAttribute('data-target'); // e.g., data-target="home-view"
                     if (targetView) {
                         showView(targetView);
                     }
                 });
             });
             */
        });


        // --- Cleanup listeners on page unload (optional but good practice) ---
        window.addEventListener('beforeunload', function() {
            if (tgUser && tgUser.id) {
                const userRef = database.ref('users/' + tgUser.id);
                if (blockingListener) {
                    userRef.child('isBlocked').off('value', blockingListener);
                }
                if (withdrawHistoryListener) {
                    userRef.child('withdrawHistory').off('value', withdrawHistoryListener);
                }
                if (userPointsBalanceListener) {
                    userRef.off('value', userPointsBalanceListener);
                }
                if (referralListener) {
                    userRef.child('referralCount').off('value', referralListener);
                    userRef.child('referralEarnings').off('value', referralListener);
                }
                if (appConfigListener) {
                    database.ref('appConfig').off('value', appConfigListener);
                }
                if (userAdDataListener) {
                    userRef.child('adsWatchedToday').off('value', userAdDataListener);
                    userRef.child('lastAdWatchTime').off('value', userAdDataListener);
                }
            }
            if (vipUpdateInterval) {
                clearInterval(vipUpdateInterval);
            }
        });


    </script>
</body>
</html>
